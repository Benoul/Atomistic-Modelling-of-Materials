# -*- coding: utf-8 -*-
"""LennyJohny.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VWqd5QbNhQ4jd4b5rAYZ127u9t80mRGB
"""

import numpy as np
import matplotlib.pyplot as plt
import random
from matplotlib.animation import FuncAnimation

N=32
n=2

def create_master_array(N, range_x, range_y, range_z, range_px, range_py, range_pz):
    marray = np.zeros((6,N))
    for i in range(N):
        #setting positions
        marray[0][i] = np.random.rand() * range_x
        marray[1][i] = np.random.rand() * range_y
        marray[2][i] = np.random.rand() * range_z
        #setting momenta
        marray[3][i] = np.random.rand() * range_px
        marray[4][i] = np.random.rand() * range_py
        marray[5][i] = np.random.rand() * range_pz
    return marray


marray = create_master_array(N, range_x=1, range_y=1, range_z=1, range_px=1, range_py=1, range_pz=1)

#let n be the size of the group of atoms that we are perturbing

def position_perturbation(N, n, pmax, marray):
    random_particle = random.sample(range(0, N), n)
    for i in random_particle:
        marray[0][i] += random.uniform(-1*pmax, pmax)
        marray[1][i] += random.uniform(-1*pmax, pmax)
        marray[2][i] += random.uniform(-1*pmax, pmax)
    return marray

position_perturbation(N, n, 0.1, marray=marray)

def U(r):
    return 4 * (r**(-12) - r**(-6))

mass = np.ones(N)

def potential_energy(marray):
    potential_energy = 0
    for i in range(N):
        for j in range(N):
            if i != j:
                seperation = np.sqrt((marray[0][i] - marray[0][j])**2 + (marray[1][i] - marray[1][j])**2 + (marray[2][i] - marray[2][j])**2)
                potential_energy += U(seperation)
    return potential_energy


def kinetic_energy(marray, mass):
    kinetic_energy = 0
    for i in range(N):
        kinetic_energy += (marray[3][i]**2 + marray[4][i]**2 + marray[5][i]**2) / (2*mass[i])
    return kinetic_energy

def total_energy(marray, mass):
    return potential_energy(marray) #+ kinetic_energy(marray, mass)
    #you can add the kinetic energy if you really wish??

print(potential_energy(marray))
print(kinetic_energy(marray, mass))

def metropolis_hastings(marray, T =1):
    perturbed_marray = position_perturbation(N, n, 0.1, marray)
    if total_energy(perturbed_marray, mass) < total_energy(marray, mass):
        marray = perturbed_marray
        return marray
    else:
        k=1 #super physical this
        if random.random() < np.exp(-(total_energy(perturbed_marray, mass) - total_energy(marray, mass))/(k*T)):
            marray = perturbed_marray
        return marray

snapshots = []
def monte_carlo(marray, flips=100):
    for i in range(flips):
        marray = metropolis_hastings(marray)
        snapshots.append(marray.copy())
    return marray

monte_carlo(marray)

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
scat = ax.scatter([], [], [], s=50)

def init():
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    return scat,

def update(frame):
    data = snapshots[frame]
    scat._offsets3d = (data[0], data[1], data[2])
    return scat,

ani = FuncAnimation(fig, update, frames=len(snapshots), init_func=init,
                    blit=False, interval=100, repeat=False)

plt.show()